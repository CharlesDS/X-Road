<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.3.xsd">
    <changeSet author="niis" id="002-history-and-functions">

        <createTable tableName="history">
            <column name="id" type="BIGSERIAL">
                <constraints nullable="false"/>
            </column>
            <column name="operation" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="table_name" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="record_id" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="field_name" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="old_value" type="TEXT">
            </column>
            <column name="new_value" type="TEXT">
            </column>
            <column name="user_name" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="timestamp" type="TIMESTAMP">
                <constraints nullable="false"/>
            </column>
        </createTable>

        <addPrimaryKey columnNames="ID" tableName="history" />

        <sql splitStatements="false">
            <!-- Wrap the SQL in CDATA in order not to mess up the XML. -->
            <![CDATA[
DO $$
BEGIN
  CREATE TYPE changed_field_type AS (field_key text, field_value text);
EXCEPTION WHEN duplicate_object THEN
  -- The type already exists.
END $$
LANGUAGE plpgsql;

-- Insert a single row to the history table.
CREATE OR REPLACE FUNCTION insert_history_row(
  user_name text, operation text, table_name text,
  field_data changed_field_type, old_data hstore, new_data hstore, record_id bigint)
RETURNS void AS $body$

DECLARE
  _history_row history;

BEGIN

  _history_row = ROW(
    NEXTVAL('history_id_seq'),
    operation, table_name, record_id,
    field_data.field_key, -- name of the field that was changed
    NULL, -- old value
    NULL, -- new value
    user_name,
    statement_timestamp()
  );

  IF (operation = 'UPDATE') THEN
    _history_row.old_value = old_data -> field_data.field_key;
    _history_row.new_value = field_data.field_value;
  ELSIF (operation = 'DELETE') THEN
    _history_row.old_value = old_data -> field_data.field_key;
  ELSIF (operation = 'INSERT') THEN
    _history_row.new_value = field_data.field_value;
  END IF;

  INSERT INTO history VALUES (_history_row.*);
END;
$body$
LANGUAGE 'plpgsql';

-- Trigger function for inserting rows to the history table for each INSERT,
-- UPDATE and DELETE operation on the tables that have this trigger set.
CREATE OR REPLACE FUNCTION add_history_rows() RETURNS TRIGGER AS $body$

DECLARE
  _record_id bigint;
  _old_data hstore;
  _new_data hstore;
  _changed_fields hstore;
  _field_data changed_field_type;
  _user_name text;
  _operation text;

BEGIN
  IF TG_WHEN <> 'AFTER' THEN
    RAISE EXCEPTION 'add_history_rows() may only be used as an AFTER trigger';
  END IF;

  IF TG_LEVEL <> 'ROW' THEN
    RAISE EXCEPTION 'add_history_rows() may only be used as a row-level trigger';
  END IF;

  _operation := TG_OP::text;

  -- Detect the type of operation, the changed fields and the ID of the changed record.
  IF (_operation = 'UPDATE') THEN
    _changed_fields := (hstore(NEW.*) - hstore(OLD.*));
    IF _changed_fields = hstore('') THEN
      -- There are no changes to record in the history table.
      RETURN NULL;
    END IF;
    _old_data := hstore(OLD.*);
    _new_data := hstore(NEW.*);
    _record_id := OLD.id;
  ELSIF (_operation = 'DELETE') THEN
    _changed_fields := hstore(OLD.*);
    _old_data := _changed_fields;
    _record_id := OLD.id;
  ELSIF (_operation = 'INSERT') THEN
    _changed_fields := hstore(NEW.*);
    _new_data := _changed_fields;
    _record_id := NEW.id;
  ELSE
    RAISE EXCEPTION 'add_history_rows() supports only INSERT, UPDATE and DELETE';
  END IF;

  -- Detect the name of the user if present.
  BEGIN
    _user_name := current_setting('xroad.user_name');
  EXCEPTION WHEN undefined_object THEN
    _user_name := session_user::text;
  END;

  -- Fill and insert a history record for each changed field.
  FOR _field_data IN SELECT kv."key", kv."value" FROM each(_changed_fields) kv
  LOOP
    PERFORM insert_history_row(
      _user_name, _operation, TG_TABLE_NAME::text,
    _field_data, _old_data, _new_data, _record_id);
  END LOOP;

  RETURN NULL;
END;
$body$
LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION _fix_sequence_all(schema_name text) RETURNS void AS $body$
DECLARE
  s INTEGER;
  t INTEGER;
  x RECORD;
BEGIN
  FOR x IN SELECT PGT.schemaname,S.relname sname ,C.attname, T.relname tname
   FROM pg_class AS S, pg_depend AS D, pg_class AS T, pg_attribute AS C, pg_tables AS PGT
   WHERE S.relkind = 'S' AND S.oid = D.objid AND D.refobjid = T.oid AND D.refobjid = C.attrelid AND D.refobjsubid = C.attnum AND T.relname = PGT.tablename AND PGT.schemaname = schema_name
   LOOP
     -- get max used value from table
     EXECUTE format('select COALESCE(max(%I),0) from %I.%I', x.attname, x.schemaname, x.tname) into t;
       LOOP
         -- roll sequence till it is bigger than used value
         EXECUTE format('select nextval(''%I.%I'')', x.schemaname, x.sname) into s;
         IF s>t THEN
           exit;
         END IF;
       END LOOP;
   END LOOP;
END;
$body$
LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION fix_sequence(schema_name text) RETURNS void AS $body$
BEGIN
  IF exists(SELECT 1 FROM pg_extension WHERE extname='bdr') THEN
    RAISE NOTICE 'BDR';
    PERFORM bdr.bdr_replicate_ddl_command(format('select %I._fix_sequence_all(%L);', schema_name, schema_name));
  ELSE
    RAISE NOTICE 'nonBDR';
    PERFORM _fix_sequence_all(schema_name);
  END IF;
END;
$body$
LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION insert_node_name() RETURNS trigger AS $body$
DECLARE
  current_ha_node_name text;
BEGIN
  current_ha_node_name := current_setting('xroad.current_ha_node_name', true);
  IF current_ha_node_name IS NOT NULL THEN
    NEW.ha_node_name := current_ha_node_name;
  ELSE
    NEW.ha_node_name := 'node_0';
  END IF;
  RETURN NEW;
END
$body$
LANGUAGE 'plpgsql';

CREATE OR REPLACE VIEW ha_cluster_status AS
 SELECT sp.ha_node_name,
    sp.value AS address,
    df.configuration_generated
   FROM (system_parameters sp
     LEFT JOIN ( SELECT distributed_files.ha_node_name,
            max(distributed_files.file_updated_at) AS configuration_generated
           FROM distributed_files
          WHERE ((distributed_files.content_identifier)::text = 'PRIVATE-PARAMETERS'::text)
          GROUP BY distributed_files.ha_node_name) df ON (((sp.ha_node_name)::text = (df.ha_node_name)::text)))
  WHERE ((sp.key)::text = 'centralServerAddress'::text);

DROP TRIGGER IF EXISTS insert_node_name ON configuration_sources;
CREATE TRIGGER insert_node_name BEFORE INSERT ON configuration_sources
    FOR EACH ROW EXECUTE PROCEDURE insert_node_name();

DROP TRIGGER IF EXISTS insert_node_name ON distributed_files;
CREATE TRIGGER insert_node_name BEFORE INSERT ON distributed_files
    FOR EACH ROW EXECUTE PROCEDURE insert_node_name();

DROP TRIGGER IF EXISTS insert_node_name ON history;
CREATE TRIGGER insert_node_name BEFORE INSERT ON history
    FOR EACH ROW EXECUTE PROCEDURE insert_node_name();

DROP TRIGGER IF EXISTS insert_node_name ON system_parameters;
CREATE TRIGGER insert_node_name BEFORE INSERT ON system_parameters
    FOR EACH ROW EXECUTE PROCEDURE insert_node_name();

DROP TRIGGER IF EXISTS update_history ON anchor_url_certs;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON anchor_url_certs
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON anchor_urls;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON anchor_urls
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON approved_cas;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON approved_cas
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON approved_tsas;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON approved_tsas
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON auth_certs;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON auth_certs
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON ca_infos;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON ca_infos
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON central_services;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON central_services
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON configuration_signing_keys;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON configuration_signing_keys
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON configuration_sources;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON configuration_sources
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

# Skip distributed_files because they it contains lots of data but only repeat the contents of the other tables.

DROP TRIGGER IF EXISTS update_history ON global_group_members;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON global_group_members
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON global_groups;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON global_groups
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON identifiers;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON identifiers
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON member_classes;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON member_classes
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON ocsp_infos;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON ocsp_infos
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON request_processings;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON request_processings
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON requests;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON requests
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON security_categories;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON security_categories
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON security_server_client_names;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON security_server_client_names
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON security_server_clients;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON security_server_clients
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON security_servers;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON security_servers
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON security_servers_security_categories;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON security_servers_security_categories
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON server_clients;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON server_clients
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON system_parameters;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON system_parameters
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON trusted_anchors;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON trusted_anchors
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();

DROP TRIGGER IF EXISTS update_history ON ui_users;
CREATE TRIGGER update_history AFTER INSERT OR UPDATE OR DELETE ON ui_users
    FOR EACH ROW EXECUTE PROCEDURE add_history_rows();


]]>
        </sql>

        <rollback>
            <![CDATA[
DROP TRIGGER IF EXISTS insert_node_name ON configuration_sources;
DROP TRIGGER IF EXISTS insert_node_name ON distributed_files;
DROP TRIGGER IF EXISTS insert_node_name ON history;
DROP TRIGGER IF EXISTS insert_node_name ON system_parameters;

DROP TRIGGER IF EXISTS update_history ON anchor_url_certs;
DROP TRIGGER IF EXISTS update_history ON anchor_urls;
DROP TRIGGER IF EXISTS update_history ON approved_cas;
DROP TRIGGER IF EXISTS update_history ON approved_tsas;
DROP TRIGGER IF EXISTS update_history ON auth_certs;
DROP TRIGGER IF EXISTS update_history ON ca_infos;
DROP TRIGGER IF EXISTS update_history ON central_services;
DROP TRIGGER IF EXISTS update_history ON configuration_signing_keys;
DROP TRIGGER IF EXISTS update_history ON configuration_sources;
DROP TRIGGER IF EXISTS update_history ON global_group_members;
DROP TRIGGER IF EXISTS update_history ON global_groups;
DROP TRIGGER IF EXISTS update_history ON identifiers;
DROP TRIGGER IF EXISTS update_history ON member_classes;
DROP TRIGGER IF EXISTS update_history ON ocsp_infos;
DROP TRIGGER IF EXISTS update_history ON request_processings;
DROP TRIGGER IF EXISTS update_history ON requests;
DROP TRIGGER IF EXISTS update_history ON security_categories;
DROP TRIGGER IF EXISTS update_history ON security_server_client_names;
DROP TRIGGER IF EXISTS update_history ON security_server_clients;
DROP TRIGGER IF EXISTS update_history ON security_servers;
DROP TRIGGER IF EXISTS update_history ON security_servers_security_categories;
DROP TRIGGER IF EXISTS update_history ON server_clients;
DROP TRIGGER IF EXISTS update_history ON system_parameters;
DROP TRIGGER IF EXISTS update_history ON trusted_anchors;
DROP TRIGGER IF EXISTS update_history ON ui_users;

DROP VIEW IF EXISTS ha_cluster_status;

DROP FUNCTION IF EXISTS insert_node_name();
DROP FUNCTION IF EXISTS fix_sequence(schema_name text);
DROP FUNCTION IF EXISTS _fix_sequence_all(schema_name text);
DROP FUNCTION IF EXISTS add_history_rows();
DROP FUNCTION IF EXISTS insert_history_row(
    user_name text, operation text, table_name text,
    field_data changed_field_type, old_data hstore, new_data hstore, record_id bigint);

DROP TYPE changed_field_type;
DROP TABLE history;
]]>
        </rollback>
    </changeSet>
</databaseChangeLog>
